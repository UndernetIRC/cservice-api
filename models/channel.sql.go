// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: channel.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/undernetirc/cservice-api/db/types/flags"
)

const addChannelMember = `-- name: AddChannelMember :one
INSERT INTO levels (channel_id, user_id, access, flags, added, added_by, last_modif, last_modif_by, last_updated)
VALUES ($1, $2, $3, 0, EXTRACT(EPOCH FROM NOW())::int, $4, EXTRACT(EPOCH FROM NOW())::int, $4, EXTRACT(EPOCH FROM NOW())::int)
RETURNING channel_id, user_id, access, added
`

type AddChannelMemberParams struct {
	ChannelID int32       `json:"channel_id"`
	UserID    int32       `json:"user_id"`
	Access    int32       `json:"access"`
	AddedBy   pgtype.Text `json:"added_by"`
}

type AddChannelMemberRow struct {
	ChannelID int32       `json:"channel_id"`
	UserID    int32       `json:"user_id"`
	Access    int32       `json:"access"`
	Added     pgtype.Int4 `json:"added"`
}

func (q *Queries) AddChannelMember(ctx context.Context, arg AddChannelMemberParams) (AddChannelMemberRow, error) {
	row := q.db.QueryRow(ctx, addChannelMember,
		arg.ChannelID,
		arg.UserID,
		arg.Access,
		arg.AddedBy,
	)
	var i AddChannelMemberRow
	err := row.Scan(
		&i.ChannelID,
		&i.UserID,
		&i.Access,
		&i.Added,
	)
	return i, err
}

const addChannelOwner = `-- name: AddChannelOwner :exec
INSERT INTO levels (
  channel_id,
  user_id,
  access,
  added,
  added_by,
  last_modif,
  last_modif_by,
  last_updated
) VALUES (
  $1, $2, 500, EXTRACT(EPOCH FROM NOW())::int, '*** REGPROC ***',
  EXTRACT(EPOCH FROM NOW())::int, '*** REGPROC ***', EXTRACT(EPOCH FROM NOW())::int
)
`

// Adds the manager as owner (access 500) for instant registration
func (q *Queries) AddChannelOwner(ctx context.Context, channelID int32, userID int32) error {
	_, err := q.db.Exec(ctx, addChannelOwner, channelID, userID)
	return err
}

const checkChannelExists = `-- name: CheckChannelExists :one
SELECT id, name, description, url
FROM channels
WHERE id = $1 AND deleted = 0
`

type CheckChannelExistsRow struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Url         pgtype.Text `json:"url"`
}

func (q *Queries) CheckChannelExists(ctx context.Context, id int32) (CheckChannelExistsRow, error) {
	row := q.db.QueryRow(ctx, checkChannelExists, id)
	var i CheckChannelExistsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Url,
	)
	return i, err
}

const checkChannelExistsAndRegistered = `-- name: CheckChannelExistsAndRegistered :one
SELECT id, name, registered_ts
FROM channels
WHERE id = $1
  AND registered_ts > 0
  AND deleted = 0
`

type CheckChannelExistsAndRegisteredRow struct {
	ID           int32       `json:"id"`
	Name         string      `json:"name"`
	RegisteredTs pgtype.Int4 `json:"registered_ts"`
}

// Validate channel exists and is registered (managerchange.php:197)
func (q *Queries) CheckChannelExistsAndRegistered(ctx context.Context, id int32) (CheckChannelExistsAndRegisteredRow, error) {
	row := q.db.QueryRow(ctx, checkChannelExistsAndRegistered, id)
	var i CheckChannelExistsAndRegisteredRow
	err := row.Scan(&i.ID, &i.Name, &i.RegisteredTs)
	return i, err
}

const checkChannelMemberExists = `-- name: CheckChannelMemberExists :one
SELECT channel_id, user_id, access
FROM levels
WHERE channel_id = $1 AND user_id = $2 AND deleted = 0
`

type CheckChannelMemberExistsRow struct {
	ChannelID int32 `json:"channel_id"`
	UserID    int32 `json:"user_id"`
	Access    int32 `json:"access"`
}

func (q *Queries) CheckChannelMemberExists(ctx context.Context, channelID int32, userID int32) (CheckChannelMemberExistsRow, error) {
	row := q.db.QueryRow(ctx, checkChannelMemberExists, channelID, userID)
	var i CheckChannelMemberExistsRow
	err := row.Scan(&i.ChannelID, &i.UserID, &i.Access)
	return i, err
}

const checkChannelNameExists = `-- name: CheckChannelNameExists :one
SELECT id, name
FROM channels
WHERE lower(name) = lower($1) AND registered_ts > 0
`

type CheckChannelNameExistsRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

// Checks if a channel name already exists
func (q *Queries) CheckChannelNameExists(ctx context.Context, lower string) (CheckChannelNameExistsRow, error) {
	row := q.db.QueryRow(ctx, checkChannelNameExists, lower)
	var i CheckChannelNameExistsRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const checkChannelSingleManager = `-- name: CheckChannelSingleManager :one
SELECT COUNT(*) as manager_count
FROM channels c
INNER JOIN levels l ON c.id = l.channel_id
WHERE c.id = $1
  AND l.access = 500
  AND c.deleted = 0
  AND l.deleted = 0
`

// Ensure channel has only one manager (managerchange.php:295)
func (q *Queries) CheckChannelSingleManager(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, checkChannelSingleManager, id)
	var manager_count int64
	err := row.Scan(&manager_count)
	return manager_count, err
}

const checkUserChannelOwnership = `-- name: CheckUserChannelOwnership :one
SELECT c.name, c.id, c.registered_ts
FROM channels c
INNER JOIN levels l ON l.channel_id = c.id
WHERE l.user_id = $1
  AND l.access = 500
  AND c.id = $2
  AND c.id > 1
  AND c.registered_ts > 0
  AND c.deleted = 0
  AND l.deleted = 0
`

type CheckUserChannelOwnershipRow struct {
	Name         string      `json:"name"`
	ID           int32       `json:"id"`
	RegisteredTs pgtype.Int4 `json:"registered_ts"`
}

// Check if user has level 500 access on channel (managerchange.php:362)
func (q *Queries) CheckUserChannelOwnership(ctx context.Context, userID int32, iD int32) (CheckUserChannelOwnershipRow, error) {
	row := q.db.QueryRow(ctx, checkUserChannelOwnership, userID, iD)
	var i CheckUserChannelOwnershipRow
	err := row.Scan(&i.Name, &i.ID, &i.RegisteredTs)
	return i, err
}

const countChannelOwners = `-- name: CountChannelOwners :one
SELECT COUNT(*) as owner_count
FROM levels
WHERE channel_id = $1 AND access = 500 AND deleted = 0
`

func (q *Queries) CountChannelOwners(ctx context.Context, channelID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countChannelOwners, channelID)
	var owner_count int64
	err := row.Scan(&owner_count)
	return owner_count, err
}

const createChannel = `-- name: CreateChannel :one

INSERT INTO channels (
  name,
  flags,
  description,
  registered_ts,
  channel_ts,
  last_updated
) VALUES (
  $1, $2, $3, EXTRACT(EPOCH FROM NOW())::int,
  EXTRACT(EPOCH FROM NOW())::int, EXTRACT(EPOCH FROM NOW())::int
) RETURNING id, name, description, registered_ts
`

type CreateChannelParams struct {
	Name        string        `json:"name"`
	Flags       flags.Channel `json:"flags"`
	Description pgtype.Text   `json:"description"`
}

type CreateChannelRow struct {
	ID           int32       `json:"id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	RegisteredTs pgtype.Int4 `json:"registered_ts"`
}

// Channel Registration INSERT queries
// Creates a new channel entry (when registration is approved)
func (q *Queries) CreateChannel(ctx context.Context, arg CreateChannelParams) (CreateChannelRow, error) {
	row := q.db.QueryRow(ctx, createChannel, arg.Name, arg.Flags, arg.Description)
	var i CreateChannelRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.RegisteredTs,
	)
	return i, err
}

const createChannelForInstantRegistration = `-- name: CreateChannelForInstantRegistration :one
INSERT INTO channels (
  name,
  mass_deop_pro,
  flood_pro,
  flags,
  limit_offset,
  limit_period,
  limit_grace,
  limit_max,
  userflags,
  url,
  description,
  keywords,
  registered_ts,
  channel_ts,
  channel_mode,
  comment,
  last_updated
) VALUES (
  $1, 0, 0, 0, 3, 20, 1, 0, 0, '', '', '',
  EXTRACT(EPOCH FROM NOW())::int, EXTRACT(EPOCH FROM NOW())::int, '', '',
  EXTRACT(EPOCH FROM NOW())::int
) RETURNING id, name, registered_ts
`

type CreateChannelForInstantRegistrationRow struct {
	ID           int32       `json:"id"`
	Name         string      `json:"name"`
	RegisteredTs pgtype.Int4 `json:"registered_ts"`
}

// Creates a new channel entry for instant registration (no supporters required)
func (q *Queries) CreateChannelForInstantRegistration(ctx context.Context, name string) (CreateChannelForInstantRegistrationRow, error) {
	row := q.db.QueryRow(ctx, createChannelForInstantRegistration, name)
	var i CreateChannelForInstantRegistrationRow
	err := row.Scan(&i.ID, &i.Name, &i.RegisteredTs)
	return i, err
}

const createChannelForRegistration = `-- name: CreateChannelForRegistration :one
INSERT INTO channels (
  name,
  mass_deop_pro,
  flood_pro,
  flags,
  limit_offset,
  limit_period,
  limit_grace,
  limit_max,
  userflags,
  url,
  description,
  keywords,
  registered_ts,
  channel_ts,
  channel_mode,
  comment,
  last_updated
) VALUES (
  $1, 0, 0, 0, 3, 20, 1, 0, 0, '', '', '', 0, 0, '', '',
  EXTRACT(EPOCH FROM NOW())::int
) RETURNING id, name
`

type CreateChannelForRegistrationRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

// Creates a new channel entry for pending registration
func (q *Queries) CreateChannelForRegistration(ctx context.Context, name string) (CreateChannelForRegistrationRow, error) {
	row := q.db.QueryRow(ctx, createChannelForRegistration, name)
	var i CreateChannelForRegistrationRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getChannelByID = `-- name: GetChannelByID :one
SELECT c.id, c.name, c.description, c.url, c.registered_ts as created_at,
       COUNT(l.user_id) as member_count
FROM channels c
LEFT JOIN levels l ON c.id = l.channel_id AND l.deleted = 0
WHERE c.id = $1
  AND c.deleted = 0
GROUP BY c.id, c.name, c.description, c.url, c.registered_ts
`

type GetChannelByIDRow struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Url         pgtype.Text `json:"url"`
	CreatedAt   pgtype.Int4 `json:"created_at"`
	MemberCount int64       `json:"member_count"`
}

func (q *Queries) GetChannelByID(ctx context.Context, id int32) (GetChannelByIDRow, error) {
	row := q.db.QueryRow(ctx, getChannelByID, id)
	var i GetChannelByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.CreatedAt,
		&i.MemberCount,
	)
	return i, err
}

const getChannelByName = `-- name: GetChannelByName :one
SELECT id, name, description, url
FROM channels
WHERE name = $1 AND deleted = 0
`

type GetChannelByNameRow struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Url         pgtype.Text `json:"url"`
}

func (q *Queries) GetChannelByName(ctx context.Context, name string) (GetChannelByNameRow, error) {
	row := q.db.QueryRow(ctx, getChannelByName, name)
	var i GetChannelByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Url,
	)
	return i, err
}

const getChannelDetails = `-- name: GetChannelDetails :one
SELECT c.id, c.name, c.description, c.url, c.registered_ts as created_at, c.last_updated,
       COUNT(l.user_id) as member_count
FROM channels c
LEFT JOIN levels l ON c.id = l.channel_id AND l.deleted = 0
WHERE c.id = $1 AND c.deleted = 0
GROUP BY c.id, c.name, c.description, c.url, c.registered_ts, c.last_updated
`

type GetChannelDetailsRow struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Url         pgtype.Text `json:"url"`
	CreatedAt   pgtype.Int4 `json:"created_at"`
	LastUpdated int32       `json:"last_updated"`
	MemberCount int64       `json:"member_count"`
}

func (q *Queries) GetChannelDetails(ctx context.Context, id int32) (GetChannelDetailsRow, error) {
	row := q.db.QueryRow(ctx, getChannelDetails, id)
	var i GetChannelDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.MemberCount,
	)
	return i, err
}

const getChannelMembersByAccessLevel = `-- name: GetChannelMembersByAccessLevel :many
SELECT user_id, access
FROM levels
WHERE channel_id = $1 AND access = $2 AND deleted = 0
ORDER BY user_id
`

type GetChannelMembersByAccessLevelRow struct {
	UserID int32 `json:"user_id"`
	Access int32 `json:"access"`
}

func (q *Queries) GetChannelMembersByAccessLevel(ctx context.Context, channelID int32, access int32) ([]GetChannelMembersByAccessLevelRow, error) {
	rows, err := q.db.Query(ctx, getChannelMembersByAccessLevel, channelID, access)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChannelMembersByAccessLevelRow{}
	for rows.Next() {
		var i GetChannelMembersByAccessLevelRow
		if err := rows.Scan(&i.UserID, &i.Access); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelUserAccess = `-- name: GetChannelUserAccess :one
SELECT l.access, l.user_id, l.channel_id
FROM levels l
WHERE l.channel_id = $1 AND l.user_id = $2 AND l.deleted = 0
`

type GetChannelUserAccessRow struct {
	Access    int32 `json:"access"`
	UserID    int32 `json:"user_id"`
	ChannelID int32 `json:"channel_id"`
}

func (q *Queries) GetChannelUserAccess(ctx context.Context, channelID int32, userID int32) (GetChannelUserAccessRow, error) {
	row := q.db.QueryRow(ctx, getChannelUserAccess, channelID, userID)
	var i GetChannelUserAccessRow
	err := row.Scan(&i.Access, &i.UserID, &i.ChannelID)
	return i, err
}

const getLastChannelRegistration = `-- name: GetLastChannelRegistration :one
SELECT c.registered_ts as last_registration
FROM channels c
INNER JOIN levels l ON c.id = l.channel_id
WHERE l.user_id = $1 AND l.access >= 500 AND l.deleted = 0 AND c.registered_ts > 0
ORDER BY c.registered_ts DESC
LIMIT 1
`

// Returns the timestamp of the user's last successful channel registration
func (q *Queries) GetLastChannelRegistration(ctx context.Context, userID int32) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getLastChannelRegistration, userID)
	var last_registration pgtype.Int4
	err := row.Scan(&last_registration)
	return last_registration, err
}

const getUserChannelCount = `-- name: GetUserChannelCount :one

SELECT COUNT(*) as channel_count
FROM levels l
INNER JOIN channels c ON l.channel_id = c.id
WHERE l.user_id = $1 AND l.access >= 500 AND l.deleted = 0 AND c.registered_ts > 0
`

// Channel Registration SELECT queries
// Returns the count of channels owned by a user
func (q *Queries) GetUserChannelCount(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getUserChannelCount, userID)
	var channel_count int64
	err := row.Scan(&channel_count)
	return channel_count, err
}

const removeChannelMember = `-- name: RemoveChannelMember :one
UPDATE levels
SET deleted = 1, last_modif = EXTRACT(EPOCH FROM NOW())::int, last_modif_by = $3, last_updated = EXTRACT(EPOCH FROM NOW())::int
WHERE channel_id = $1 AND user_id = $2 AND deleted = 0
RETURNING channel_id, user_id, access, last_modif
`

type RemoveChannelMemberParams struct {
	ChannelID   int32       `json:"channel_id"`
	UserID      int32       `json:"user_id"`
	LastModifBy pgtype.Text `json:"last_modif_by"`
}

type RemoveChannelMemberRow struct {
	ChannelID int32       `json:"channel_id"`
	UserID    int32       `json:"user_id"`
	Access    int32       `json:"access"`
	LastModif pgtype.Int4 `json:"last_modif"`
}

func (q *Queries) RemoveChannelMember(ctx context.Context, arg RemoveChannelMemberParams) (RemoveChannelMemberRow, error) {
	row := q.db.QueryRow(ctx, removeChannelMember, arg.ChannelID, arg.UserID, arg.LastModifBy)
	var i RemoveChannelMemberRow
	err := row.Scan(
		&i.ChannelID,
		&i.UserID,
		&i.Access,
		&i.LastModif,
	)
	return i, err
}

const searchChannels = `-- name: SearchChannels :many
SELECT c.id, c.name, c.description, c.url, c.registered_ts as created_at,
       COUNT(l.user_id) as member_count
FROM channels c
LEFT JOIN levels l ON c.id = l.channel_id AND l.deleted = 0
WHERE c.name ILIKE $1
  AND c.deleted = 0
GROUP BY c.id, c.name, c.description, c.url, c.registered_ts
ORDER BY member_count DESC, c.name ASC
LIMIT $2 OFFSET $3
`

type SearchChannelsParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchChannelsRow struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Url         pgtype.Text `json:"url"`
	CreatedAt   pgtype.Int4 `json:"created_at"`
	MemberCount int64       `json:"member_count"`
}

func (q *Queries) SearchChannels(ctx context.Context, arg SearchChannelsParams) ([]SearchChannelsRow, error) {
	rows, err := q.db.Query(ctx, searchChannels, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchChannelsRow{}
	for rows.Next() {
		var i SearchChannelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.CreatedAt,
			&i.MemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChannelsCount = `-- name: SearchChannelsCount :one
SELECT COUNT(DISTINCT c.id) as total
FROM channels c
WHERE c.name ILIKE $1
  AND c.deleted = 0
`

func (q *Queries) SearchChannelsCount(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, searchChannelsCount, name)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const softDeleteChannel = `-- name: SoftDeleteChannel :exec

UPDATE channels
SET registered_ts = 0,
    last_updated = EXTRACT(EPOCH FROM NOW())::int
WHERE id = $1
`

// Channel Registration DELETE queries
// Soft deletes a channel by setting registered_ts to 0
func (q *Queries) SoftDeleteChannel(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteChannel, id)
	return err
}

const updateChannelRegistrationStatus = `-- name: UpdateChannelRegistrationStatus :exec

UPDATE channels
SET registered_ts = EXTRACT(EPOCH FROM NOW())::int,
    last_updated = EXTRACT(EPOCH FROM NOW())::int
WHERE id = $1
`

// Channel Registration UPDATE queries
// Updates channel registration related timestamps and status
func (q *Queries) UpdateChannelRegistrationStatus(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateChannelRegistrationStatus, id)
	return err
}

const updateChannelSettings = `-- name: UpdateChannelSettings :one
UPDATE channels
SET description = $2, url = $3, last_updated = EXTRACT(EPOCH FROM NOW())::int
WHERE id = $1 AND deleted = 0
RETURNING id, name, description, url, registered_ts as created_at, last_updated
`

type UpdateChannelSettingsParams struct {
	ID          int32       `json:"id"`
	Description pgtype.Text `json:"description"`
	Url         pgtype.Text `json:"url"`
}

type UpdateChannelSettingsRow struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Url         pgtype.Text `json:"url"`
	CreatedAt   pgtype.Int4 `json:"created_at"`
	LastUpdated int32       `json:"last_updated"`
}

func (q *Queries) UpdateChannelSettings(ctx context.Context, arg UpdateChannelSettingsParams) (UpdateChannelSettingsRow, error) {
	row := q.db.QueryRow(ctx, updateChannelSettings, arg.ID, arg.Description, arg.Url)
	var i UpdateChannelSettingsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.CreatedAt,
		&i.LastUpdated,
	)
	return i, err
}
