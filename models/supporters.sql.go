// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: supporters.sql

package models

import (
	"context"
)

const checkMultipleSupportersConcurrentSupports = `-- name: CheckMultipleSupportersConcurrentSupports :many
SELECT
  u.id,
  u.user_name,
  COUNT(s.channel_id) as support_count,
  CASE
    WHEN COUNT(s.channel_id) >= $2::int THEN true
    ELSE false
  END as exceeds_limit
FROM users u
LEFT JOIN supporters s ON u.id = s.user_id
LEFT JOIN pending p ON s.channel_id = p.channel_id
LEFT JOIN channels c ON s.channel_id = c.id
WHERE lower(u.user_name) = ANY(SELECT lower(unnest($1::text[])))
  AND (s.channel_id IS NULL OR ((p.status < 3 OR p.status = 8) AND c.registered_ts = 0))
GROUP BY u.id, u.user_name
`

type CheckMultipleSupportersConcurrentSupportsRow struct {
	ID           int32  `json:"id"`
	Username     string `json:"user_name"`
	SupportCount int64  `json:"support_count"`
	ExceedsLimit bool   `json:"exceeds_limit"`
}

// Efficiently checks concurrent supports for multiple supporters at once
func (q *Queries) CheckMultipleSupportersConcurrentSupports(ctx context.Context, column1 []string, column2 int32) ([]CheckMultipleSupportersConcurrentSupportsRow, error) {
	rows, err := q.db.Query(ctx, checkMultipleSupportersConcurrentSupports, column1, column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckMultipleSupportersConcurrentSupportsRow{}
	for rows.Next() {
		var i CheckMultipleSupportersConcurrentSupportsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.SupportCount,
			&i.ExceedsLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkSupporterConcurrentSupports = `-- name: CheckSupporterConcurrentSupports :one
SELECT COUNT(*) as support_count
FROM supporters s
INNER JOIN pending p ON s.channel_id = p.channel_id
INNER JOIN channels c ON s.channel_id = c.id
WHERE s.user_id = $1
  AND (p.status < 3 OR p.status = 8)
  AND c.registered_ts = 0
`

// Checks how many channels a supporter is currently supporting
func (q *Queries) CheckSupporterConcurrentSupports(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, checkSupporterConcurrentSupports, userID)
	var support_count int64
	err := row.Scan(&support_count)
	return support_count, err
}

const createChannelSupporter = `-- name: CreateChannelSupporter :exec

INSERT INTO supporters (
  channel_id,
  user_id,
  support,
  join_count,
  last_updated
) VALUES (
  $1, $2, 'Y', 0, EXTRACT(EPOCH FROM NOW())::int
)
`

// Supporters table queries for channel registration
// Adds a supporter to a pending channel registration
func (q *Queries) CreateChannelSupporter(ctx context.Context, channelID int32, userID int32) error {
	_, err := q.db.Exec(ctx, createChannelSupporter, channelID, userID)
	return err
}

const deleteChannelSupporters = `-- name: DeleteChannelSupporters :exec
DELETE FROM supporters
WHERE channel_id = $1
`

// Removes all supporters for a pending channel
func (q *Queries) DeleteChannelSupporters(ctx context.Context, channelID int32) error {
	_, err := q.db.Exec(ctx, deleteChannelSupporters, channelID)
	return err
}

const deleteSpecificChannelSupporter = `-- name: DeleteSpecificChannelSupporter :exec
DELETE FROM supporters
WHERE channel_id = $1 AND user_id = $2
`

// Removes a specific supporter from a pending channel
func (q *Queries) DeleteSpecificChannelSupporter(ctx context.Context, channelID int32, userID int32) error {
	_, err := q.db.Exec(ctx, deleteSpecificChannelSupporter, channelID, userID)
	return err
}
