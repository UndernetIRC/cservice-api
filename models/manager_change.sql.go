// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: manager_change.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkExistingPendingRequests = `-- name: CheckExistingPendingRequests :many

SELECT id, channel_id, confirmed, change_type
FROM pending_mgrchange
WHERE channel_id = $1
  AND (confirmed = '1' OR confirmed = '3')
`

type CheckExistingPendingRequestsRow struct {
	ID         pgtype.Int4 `json:"id"`
	ChannelID  int32       `json:"channel_id"`
	Confirmed  pgtype.Int2 `json:"confirmed"`
	ChangeType pgtype.Int2 `json:"change_type"`
}

// Manager Change SQL Queries
// Based on legacy PHP implementation with optimizations
// Check for existing pending requests (managerchange.php:206,217)
func (q *Queries) CheckExistingPendingRequests(ctx context.Context, channelID int32) ([]CheckExistingPendingRequestsRow, error) {
	rows, err := q.db.Query(ctx, checkExistingPendingRequests, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckExistingPendingRequestsRow{}
	for rows.Next() {
		var i CheckExistingPendingRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChannelID,
			&i.Confirmed,
			&i.ChangeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cleanupExpiredManagerChangeRequests = `-- name: CleanupExpiredManagerChangeRequests :exec
DELETE FROM pending_mgrchange
WHERE expiration < EXTRACT(EPOCH FROM NOW())::int
  AND confirmed = '0'
`

// Clean up expired unconfirmed requests (confirm_mgrchange.php:16)
func (q *Queries) CleanupExpiredManagerChangeRequests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredManagerChangeRequests)
	return err
}

const confirmManagerChangeRequest = `-- name: ConfirmManagerChangeRequest :exec
UPDATE pending_mgrchange
SET confirmed = '1'
WHERE crc = $1
  AND confirmed = '0'
`

// Mark request as confirmed (confirm_mgrchange.php:25)
func (q *Queries) ConfirmManagerChangeRequest(ctx context.Context, crc pgtype.Text) error {
	_, err := q.db.Exec(ctx, confirmManagerChangeRequest, crc)
	return err
}

const getManagerChangeRequestByToken = `-- name: GetManagerChangeRequestByToken :one
SELECT pm.id, pm.channel_id, pm.manager_id, pm.new_manager_id, pm.change_type, pm.opt_duration, pm.reason, pm.expiration, pm.crc, pm.confirmed, pm.from_host, c.name as channel_name
FROM pending_mgrchange pm
INNER JOIN channels c ON c.id = pm.channel_id
WHERE pm.crc = $1
  AND pm.expiration >= EXTRACT(EPOCH FROM NOW())::int
  AND pm.confirmed = '0'
  AND c.deleted = 0
`

type GetManagerChangeRequestByTokenRow struct {
	ID           pgtype.Int4 `json:"id"`
	ChannelID    int32       `json:"channel_id"`
	ManagerID    int32       `json:"manager_id"`
	NewManagerID int32       `json:"new_manager_id"`
	ChangeType   pgtype.Int2 `json:"change_type"`
	OptDuration  pgtype.Int4 `json:"opt_duration"`
	Reason       pgtype.Text `json:"reason"`
	Expiration   pgtype.Int4 `json:"expiration"`
	Crc          pgtype.Text `json:"crc"`
	Confirmed    pgtype.Int2 `json:"confirmed"`
	FromHost     pgtype.Text `json:"from_host"`
	ChannelName  string      `json:"channel_name"`
}

// Validate confirmation token (confirm_mgrchange.php:17)
func (q *Queries) GetManagerChangeRequestByToken(ctx context.Context, crc pgtype.Text) (GetManagerChangeRequestByTokenRow, error) {
	row := q.db.QueryRow(ctx, getManagerChangeRequestByToken, crc)
	var i GetManagerChangeRequestByTokenRow
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ManagerID,
		&i.NewManagerID,
		&i.ChangeType,
		&i.OptDuration,
		&i.Reason,
		&i.Expiration,
		&i.Crc,
		&i.Confirmed,
		&i.FromHost,
		&i.ChannelName,
	)
	return i, err
}

const getManagerChangeRequestStatus = `-- name: GetManagerChangeRequestStatus :one
SELECT pm.id, pm.channel_id, pm.change_type, pm.confirmed,
       pm.expiration, pm.reason, pm.opt_duration,
       u.user_name as new_manager_username
FROM pending_mgrchange pm
INNER JOIN users u ON u.id = pm.new_manager_id
WHERE pm.channel_id = $1
  AND pm.confirmed IN ('0', '1')
ORDER BY pm.id DESC
LIMIT 1
`

type GetManagerChangeRequestStatusRow struct {
	ID                 pgtype.Int4 `json:"id"`
	ChannelID          int32       `json:"channel_id"`
	ChangeType         pgtype.Int2 `json:"change_type"`
	Confirmed          pgtype.Int2 `json:"confirmed"`
	Expiration         pgtype.Int4 `json:"expiration"`
	Reason             pgtype.Text `json:"reason"`
	OptDuration        pgtype.Int4 `json:"opt_duration"`
	NewManagerUsername string      `json:"new_manager_username"`
}

// Get status of pending manager change requests for a channel
func (q *Queries) GetManagerChangeRequestStatus(ctx context.Context, channelID int32) (GetManagerChangeRequestStatusRow, error) {
	row := q.db.QueryRow(ctx, getManagerChangeRequestStatus, channelID)
	var i GetManagerChangeRequestStatusRow
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ChangeType,
		&i.Confirmed,
		&i.Expiration,
		&i.Reason,
		&i.OptDuration,
		&i.NewManagerUsername,
	)
	return i, err
}

const insertManagerChangeRequest = `-- name: InsertManagerChangeRequest :one
INSERT INTO pending_mgrchange (
    channel_id, manager_id, new_manager_id, change_type,
    opt_duration, reason, expiration, crc, confirmed, from_host
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 0, $9)
RETURNING id
`

type InsertManagerChangeRequestParams struct {
	ChannelID    int32       `json:"channel_id"`
	ManagerID    int32       `json:"manager_id"`
	NewManagerID int32       `json:"new_manager_id"`
	ChangeType   pgtype.Int2 `json:"change_type"`
	OptDuration  pgtype.Int4 `json:"opt_duration"`
	Reason       pgtype.Text `json:"reason"`
	Expiration   pgtype.Int4 `json:"expiration"`
	Crc          pgtype.Text `json:"crc"`
	FromHost     pgtype.Text `json:"from_host"`
}

// Create pending manager change request (managerchange.php:327-328)
func (q *Queries) InsertManagerChangeRequest(ctx context.Context, arg InsertManagerChangeRequestParams) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, insertManagerChangeRequest,
		arg.ChannelID,
		arg.ManagerID,
		arg.NewManagerID,
		arg.ChangeType,
		arg.OptDuration,
		arg.Reason,
		arg.Expiration,
		arg.Crc,
		arg.FromHost,
	)
	var id pgtype.Int4
	err := row.Scan(&id)
	return id, err
}
