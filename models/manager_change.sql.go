// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: manager_change.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkChannelExistsAndRegistered = `-- name: CheckChannelExistsAndRegistered :one
SELECT id, name, registered_ts
FROM channels
WHERE id = $1
  AND registered_ts > 0
  AND deleted = 0
`

type CheckChannelExistsAndRegisteredRow struct {
	ID           int32       `json:"id"`
	Name         string      `json:"name"`
	RegisteredTs pgtype.Int4 `json:"registered_ts"`
}

// Validate channel exists and is registered (managerchange.php:197)
func (q *Queries) CheckChannelExistsAndRegistered(ctx context.Context, id int32) (CheckChannelExistsAndRegisteredRow, error) {
	row := q.db.QueryRow(ctx, checkChannelExistsAndRegistered, id)
	var i CheckChannelExistsAndRegisteredRow
	err := row.Scan(&i.ID, &i.Name, &i.RegisteredTs)
	return i, err
}

const checkChannelSingleManager = `-- name: CheckChannelSingleManager :one
SELECT COUNT(*) as manager_count
FROM channels c
INNER JOIN levels l ON c.id = l.channel_id
WHERE c.id = $1
  AND l.access = 500
  AND c.deleted = 0
  AND l.deleted = 0
`

// Ensure channel has only one manager (managerchange.php:295)
func (q *Queries) CheckChannelSingleManager(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, checkChannelSingleManager, id)
	var manager_count int64
	err := row.Scan(&manager_count)
	return manager_count, err
}

const checkExistingPendingRequests = `-- name: CheckExistingPendingRequests :many
SELECT id, channel_id, confirmed, change_type
FROM pending_mgrchange
WHERE channel_id = $1
  AND (confirmed = '1' OR confirmed = '3')
`

type CheckExistingPendingRequestsRow struct {
	ID         pgtype.Int4 `json:"id"`
	ChannelID  int32       `json:"channel_id"`
	Confirmed  pgtype.Int2 `json:"confirmed"`
	ChangeType pgtype.Int2 `json:"change_type"`
}

// Check for existing pending requests (managerchange.php:206,217)
func (q *Queries) CheckExistingPendingRequests(ctx context.Context, channelID int32) ([]CheckExistingPendingRequestsRow, error) {
	rows, err := q.db.Query(ctx, checkExistingPendingRequests, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckExistingPendingRequestsRow{}
	for rows.Next() {
		var i CheckExistingPendingRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChannelID,
			&i.Confirmed,
			&i.ChangeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkNewManagerChannelAccess = `-- name: CheckNewManagerChannelAccess :one
SELECT u.user_name, u.id, u.signup_ts
FROM users u
INNER JOIN levels l ON u.id = l.user_id
LEFT JOIN users_lastseen ul ON u.id = ul.user_id
WHERE l.channel_id = $1
  AND l.access = 499
  AND u.id = $2
  AND l.deleted = 0
  AND ul.last_seen > (EXTRACT(EPOCH FROM NOW())::int - 86400*20)
`

type CheckNewManagerChannelAccessRow struct {
	Username string      `json:"user_name"`
	ID       int32       `json:"id"`
	SignupTs pgtype.Int4 `json:"signup_ts"`
}

// Check new manager has level 499 on channel (managerchange.php:433)
func (q *Queries) CheckNewManagerChannelAccess(ctx context.Context, channelID int32, iD int32) (CheckNewManagerChannelAccessRow, error) {
	row := q.db.QueryRow(ctx, checkNewManagerChannelAccess, channelID, iD)
	var i CheckNewManagerChannelAccessRow
	err := row.Scan(&i.Username, &i.ID, &i.SignupTs)
	return i, err
}

const checkUserChannelOwnership = `-- name: CheckUserChannelOwnership :one

SELECT c.name, c.id, c.registered_ts
FROM channels c
INNER JOIN levels l ON l.channel_id = c.id
WHERE l.user_id = $1
  AND l.access = 500
  AND c.id = $2
  AND c.id > 1
  AND c.registered_ts > 0
  AND c.deleted = 0
  AND l.deleted = 0
`

type CheckUserChannelOwnershipRow struct {
	Name         string      `json:"name"`
	ID           int32       `json:"id"`
	RegisteredTs pgtype.Int4 `json:"registered_ts"`
}

// Manager Change SQL Queries
// Based on legacy PHP implementation with optimizations
// Check if user has level 500 access on channel (managerchange.php:362)
func (q *Queries) CheckUserChannelOwnership(ctx context.Context, userID int32, iD int32) (CheckUserChannelOwnershipRow, error) {
	row := q.db.QueryRow(ctx, checkUserChannelOwnership, userID, iD)
	var i CheckUserChannelOwnershipRow
	err := row.Scan(&i.Name, &i.ID, &i.RegisteredTs)
	return i, err
}

const checkUserCooldownStatus = `-- name: CheckUserCooldownStatus :one
SELECT post_forms, verificationdata, email
FROM users
WHERE id = $1
`

type CheckUserCooldownStatusRow struct {
	PostForms        int32       `json:"post_forms"`
	Verificationdata pgtype.Text `json:"verificationdata"`
	Email            pgtype.Text `json:"email"`
}

// Check user form submission cooldown status
func (q *Queries) CheckUserCooldownStatus(ctx context.Context, id int32) (CheckUserCooldownStatusRow, error) {
	row := q.db.QueryRow(ctx, checkUserCooldownStatus, id)
	var i CheckUserCooldownStatusRow
	err := row.Scan(&i.PostForms, &i.Verificationdata, &i.Email)
	return i, err
}

const checkUserOwnsOtherChannels = `-- name: CheckUserOwnsOtherChannels :one
SELECT EXISTS(
  SELECT 1
  FROM users u
  INNER JOIN levels l ON u.id = l.user_id
  INNER JOIN channels c ON c.id = l.channel_id
  WHERE u.id = $1
    AND l.access = 500
    AND c.registered_ts > 0
    AND c.deleted = 0
    AND l.deleted = 0
) as owns_channels
`

// Check if user already owns other channels (managerchange.php:443)
func (q *Queries) CheckUserOwnsOtherChannels(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserOwnsOtherChannels, id)
	var owns_channels bool
	err := row.Scan(&owns_channels)
	return owns_channels, err
}

const cleanupExpiredManagerChangeRequests = `-- name: CleanupExpiredManagerChangeRequests :exec
DELETE FROM pending_mgrchange
WHERE expiration < EXTRACT(EPOCH FROM NOW())::int
  AND confirmed = '0'
`

// Clean up expired unconfirmed requests (confirm_mgrchange.php:16)
func (q *Queries) CleanupExpiredManagerChangeRequests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredManagerChangeRequests)
	return err
}

const confirmManagerChangeRequest = `-- name: ConfirmManagerChangeRequest :exec
UPDATE pending_mgrchange
SET confirmed = '1'
WHERE crc = $1
  AND confirmed = '0'
`

// Mark request as confirmed (confirm_mgrchange.php:25)
func (q *Queries) ConfirmManagerChangeRequest(ctx context.Context, crc pgtype.Text) error {
	_, err := q.db.Exec(ctx, confirmManagerChangeRequest, crc)
	return err
}

const getManagerChangeRequestByToken = `-- name: GetManagerChangeRequestByToken :one
SELECT pm.id, pm.channel_id, pm.manager_id, pm.new_manager_id, pm.change_type, pm.opt_duration, pm.reason, pm.expiration, pm.crc, pm.confirmed, pm.from_host, c.name as channel_name
FROM pending_mgrchange pm
INNER JOIN channels c ON c.id = pm.channel_id
WHERE pm.crc = $1
  AND pm.expiration >= EXTRACT(EPOCH FROM NOW())::int
  AND pm.confirmed = '0'
  AND c.deleted = 0
`

type GetManagerChangeRequestByTokenRow struct {
	ID           pgtype.Int4 `json:"id"`
	ChannelID    int32       `json:"channel_id"`
	ManagerID    int32       `json:"manager_id"`
	NewManagerID int32       `json:"new_manager_id"`
	ChangeType   pgtype.Int2 `json:"change_type"`
	OptDuration  pgtype.Int4 `json:"opt_duration"`
	Reason       pgtype.Text `json:"reason"`
	Expiration   pgtype.Int4 `json:"expiration"`
	Crc          pgtype.Text `json:"crc"`
	Confirmed    pgtype.Int2 `json:"confirmed"`
	FromHost     pgtype.Text `json:"from_host"`
	ChannelName  string      `json:"channel_name"`
}

// Validate confirmation token (confirm_mgrchange.php:17)
func (q *Queries) GetManagerChangeRequestByToken(ctx context.Context, crc pgtype.Text) (GetManagerChangeRequestByTokenRow, error) {
	row := q.db.QueryRow(ctx, getManagerChangeRequestByToken, crc)
	var i GetManagerChangeRequestByTokenRow
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ManagerID,
		&i.NewManagerID,
		&i.ChangeType,
		&i.OptDuration,
		&i.Reason,
		&i.Expiration,
		&i.Crc,
		&i.Confirmed,
		&i.FromHost,
		&i.ChannelName,
	)
	return i, err
}

const getManagerChangeRequestStatus = `-- name: GetManagerChangeRequestStatus :one
SELECT pm.id, pm.channel_id, pm.change_type, pm.confirmed,
       pm.expiration, pm.reason, pm.opt_duration,
       u.user_name as new_manager_username
FROM pending_mgrchange pm
INNER JOIN users u ON u.id = pm.new_manager_id
WHERE pm.channel_id = $1
  AND pm.confirmed IN ('0', '1')
ORDER BY pm.id DESC
LIMIT 1
`

type GetManagerChangeRequestStatusRow struct {
	ID                 pgtype.Int4 `json:"id"`
	ChannelID          int32       `json:"channel_id"`
	ChangeType         pgtype.Int2 `json:"change_type"`
	Confirmed          pgtype.Int2 `json:"confirmed"`
	Expiration         pgtype.Int4 `json:"expiration"`
	Reason             pgtype.Text `json:"reason"`
	OptDuration        pgtype.Int4 `json:"opt_duration"`
	NewManagerUsername string      `json:"new_manager_username"`
}

// Get status of pending manager change requests for a channel
func (q *Queries) GetManagerChangeRequestStatus(ctx context.Context, channelID int32) (GetManagerChangeRequestStatusRow, error) {
	row := q.db.QueryRow(ctx, getManagerChangeRequestStatus, channelID)
	var i GetManagerChangeRequestStatusRow
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ChangeType,
		&i.Confirmed,
		&i.Expiration,
		&i.Reason,
		&i.OptDuration,
		&i.NewManagerUsername,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, user_name, signup_ts
FROM users
WHERE lower(user_name) = lower($1)
`

type GetUserByUsernameRow struct {
	ID       int32       `json:"id"`
	Email    pgtype.Text `json:"email"`
	Username string      `json:"user_name"`
	SignupTs pgtype.Int4 `json:"signup_ts"`
}

// Validate new manager exists (managerchange.php:169)
func (q *Queries) GetUserByUsername(ctx context.Context, lower string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, lower)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.SignupTs,
	)
	return i, err
}

const insertManagerChangeRequest = `-- name: InsertManagerChangeRequest :one
INSERT INTO pending_mgrchange (
    channel_id, manager_id, new_manager_id, change_type,
    opt_duration, reason, expiration, crc, confirmed, from_host
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 0, $9)
RETURNING id
`

type InsertManagerChangeRequestParams struct {
	ChannelID    int32       `json:"channel_id"`
	ManagerID    int32       `json:"manager_id"`
	NewManagerID int32       `json:"new_manager_id"`
	ChangeType   pgtype.Int2 `json:"change_type"`
	OptDuration  pgtype.Int4 `json:"opt_duration"`
	Reason       pgtype.Text `json:"reason"`
	Expiration   pgtype.Int4 `json:"expiration"`
	Crc          pgtype.Text `json:"crc"`
	FromHost     pgtype.Text `json:"from_host"`
}

// Create pending manager change request (managerchange.php:327-328)
func (q *Queries) InsertManagerChangeRequest(ctx context.Context, arg InsertManagerChangeRequestParams) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, insertManagerChangeRequest,
		arg.ChannelID,
		arg.ManagerID,
		arg.NewManagerID,
		arg.ChangeType,
		arg.OptDuration,
		arg.Reason,
		arg.Expiration,
		arg.Crc,
		arg.FromHost,
	)
	var id pgtype.Int4
	err := row.Scan(&id)
	return id, err
}

const updateUserCooldown = `-- name: UpdateUserCooldown :exec
UPDATE users
SET post_forms = (EXTRACT(EPOCH FROM NOW())::int + $2)
WHERE id = $1
`

// Set user form submission cooldown (managerchange.php:352)
func (q *Queries) UpdateUserCooldown(ctx context.Context, iD int32, column2 interface{}) error {
	_, err := q.db.Exec(ctx, updateUserCooldown, iD, column2)
	return err
}
