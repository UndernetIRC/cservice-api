// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pending.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkPendingChannelNameConflict = `-- name: CheckPendingChannelNameConflict :one
SELECT
  p.created_ts,
  p.manager_id,
  u.user_name as manager_name
FROM pending p
INNER JOIN channels c ON p.channel_id = c.id
INNER JOIN users u ON p.manager_id = u.id
WHERE lower(c.name) = lower($1)
  AND (p.status < 3 OR p.status = 8)
  AND c.registered_ts = 0
LIMIT 1
`

type CheckPendingChannelNameConflictRow struct {
	CreatedTs   int32       `json:"created_ts"`
	ManagerID   pgtype.Int4 `json:"manager_id"`
	ManagerName string      `json:"manager_name"`
}

// Checks if there's already a pending registration for this channel name
func (q *Queries) CheckPendingChannelNameConflict(ctx context.Context, lower string) (CheckPendingChannelNameConflictRow, error) {
	row := q.db.QueryRow(ctx, checkPendingChannelNameConflict, lower)
	var i CheckPendingChannelNameConflictRow
	err := row.Scan(&i.CreatedTs, &i.ManagerID, &i.ManagerName)
	return i, err
}

const createInstantRegistration = `-- name: CreateInstantRegistration :one
INSERT INTO pending (
  channel_id,
  manager_id,
  created_ts,
  check_start_ts,
  status,
  decision_ts,
  decision,
  managername,
  description,
  reg_acknowledged,
  last_updated
) VALUES (
  $1, $2, EXTRACT(EPOCH FROM NOW())::int, 0, 3,
  EXTRACT(EPOCH FROM NOW())::int, '** INSTANT REGISTRATION **',
  $3, $4, 'Y', EXTRACT(EPOCH FROM NOW())::int
) RETURNING channel_id, manager_id, created_ts
`

type CreateInstantRegistrationParams struct {
	ChannelID   int32       `json:"channel_id"`
	ManagerID   pgtype.Int4 `json:"manager_id"`
	Managername pgtype.Text `json:"managername"`
	Description pgtype.Text `json:"description"`
}

type CreateInstantRegistrationRow struct {
	ChannelID int32       `json:"channel_id"`
	ManagerID pgtype.Int4 `json:"manager_id"`
	CreatedTs int32       `json:"created_ts"`
}

// Creates an instant registration (when no supporters required)
func (q *Queries) CreateInstantRegistration(ctx context.Context, arg CreateInstantRegistrationParams) (CreateInstantRegistrationRow, error) {
	row := q.db.QueryRow(ctx, createInstantRegistration,
		arg.ChannelID,
		arg.ManagerID,
		arg.Managername,
		arg.Description,
	)
	var i CreateInstantRegistrationRow
	err := row.Scan(&i.ChannelID, &i.ManagerID, &i.CreatedTs)
	return i, err
}

const createPendingChannel = `-- name: CreatePendingChannel :one
INSERT INTO pending (
  channel_id,
  manager_id,
  created_ts,
  check_start_ts,
  status,
  managername,
  description,
  last_updated
) VALUES (
  $1, $2, EXTRACT(EPOCH FROM NOW())::int, EXTRACT(EPOCH FROM NOW())::int,
  0, $3, $4, EXTRACT(EPOCH FROM NOW())::int
) RETURNING channel_id, manager_id, created_ts
`

type CreatePendingChannelParams struct {
	ChannelID   int32       `json:"channel_id"`
	ManagerID   pgtype.Int4 `json:"manager_id"`
	Managername pgtype.Text `json:"managername"`
	Description pgtype.Text `json:"description"`
}

type CreatePendingChannelRow struct {
	ChannelID int32       `json:"channel_id"`
	ManagerID pgtype.Int4 `json:"manager_id"`
	CreatedTs int32       `json:"created_ts"`
}

// Creates a new pending channel registration
func (q *Queries) CreatePendingChannel(ctx context.Context, arg CreatePendingChannelParams) (CreatePendingChannelRow, error) {
	row := q.db.QueryRow(ctx, createPendingChannel,
		arg.ChannelID,
		arg.ManagerID,
		arg.Managername,
		arg.Description,
	)
	var i CreatePendingChannelRow
	err := row.Scan(&i.ChannelID, &i.ManagerID, &i.CreatedTs)
	return i, err
}

const deletePendingChannel = `-- name: DeletePendingChannel :exec
DELETE FROM pending
WHERE channel_id = $1
`

// Removes a pending channel registration
func (q *Queries) DeletePendingChannel(ctx context.Context, channelID int32) error {
	_, err := q.db.Exec(ctx, deletePendingChannel, channelID)
	return err
}

const getUserPendingRegistrations = `-- name: GetUserPendingRegistrations :one

SELECT COUNT(*) as pending_count
FROM pending
WHERE manager_id = $1
`

// Pending table queries for channel registration
// Returns the count of pending channel registrations for a user
func (q *Queries) GetUserPendingRegistrations(ctx context.Context, managerID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, getUserPendingRegistrations, managerID)
	var pending_count int64
	err := row.Scan(&pending_count)
	return pending_count, err
}

const updatePendingChannelDescription = `-- name: UpdatePendingChannelDescription :exec
UPDATE pending
SET description = $2,
    last_updated = EXTRACT(EPOCH FROM NOW())::int
WHERE channel_id = $1
`

// Updates the description of a pending channel registration
func (q *Queries) UpdatePendingChannelDescription(ctx context.Context, channelID int32, description pgtype.Text) error {
	_, err := q.db.Exec(ctx, updatePendingChannelDescription, channelID, description)
	return err
}

const updatePendingChannelStatus = `-- name: UpdatePendingChannelStatus :one
UPDATE pending
SET status = $2,
    decision_ts = EXTRACT(EPOCH FROM NOW())::int,
    decision = $3,
    reviewed = 'Y',
    reviewed_by_id = $4,
    last_updated = EXTRACT(EPOCH FROM NOW())::int
WHERE channel_id = $1
RETURNING channel_id, manager_id, status, decision_ts
`

type UpdatePendingChannelStatusParams struct {
	ChannelID    int32       `json:"channel_id"`
	Status       pgtype.Int4 `json:"status"`
	Decision     pgtype.Text `json:"decision"`
	ReviewedByID pgtype.Int4 `json:"reviewed_by_id"`
}

type UpdatePendingChannelStatusRow struct {
	ChannelID  int32       `json:"channel_id"`
	ManagerID  pgtype.Int4 `json:"manager_id"`
	Status     pgtype.Int4 `json:"status"`
	DecisionTs pgtype.Int4 `json:"decision_ts"`
}

// Updates the status of a pending channel registration
func (q *Queries) UpdatePendingChannelStatus(ctx context.Context, arg UpdatePendingChannelStatusParams) (UpdatePendingChannelStatusRow, error) {
	row := q.db.QueryRow(ctx, updatePendingChannelStatus,
		arg.ChannelID,
		arg.Status,
		arg.Decision,
		arg.ReviewedByID,
	)
	var i UpdatePendingChannelStatusRow
	err := row.Scan(
		&i.ChannelID,
		&i.ManagerID,
		&i.Status,
		&i.DecisionTs,
	)
	return i, err
}
