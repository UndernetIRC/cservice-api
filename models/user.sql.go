// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/undernetirc/cservice-api/db/types/flags"
	"github.com/undernetirc/cservice-api/db/types/password"
)

const checkNewManagerChannelAccess = `-- name: CheckNewManagerChannelAccess :one
SELECT u.user_name, u.id, u.signup_ts
FROM users u
INNER JOIN levels l ON u.id = l.user_id
LEFT JOIN users_lastseen ul ON u.id = ul.user_id
WHERE l.channel_id = $1
  AND l.access = 499
  AND u.id = $2
  AND l.deleted = 0
  AND ul.last_seen > (EXTRACT(EPOCH FROM NOW())::int - 86400*20)
`

type CheckNewManagerChannelAccessRow struct {
	Username string      `json:"user_name"`
	ID       int32       `json:"id"`
	SignupTs pgtype.Int4 `json:"signup_ts"`
}

// Check new manager has level 499 on channel (managerchange.php:433)
func (q *Queries) CheckNewManagerChannelAccess(ctx context.Context, channelID int32, iD int32) (CheckNewManagerChannelAccessRow, error) {
	row := q.db.QueryRow(ctx, checkNewManagerChannelAccess, channelID, iD)
	var i CheckNewManagerChannelAccessRow
	err := row.Scan(&i.Username, &i.ID, &i.SignupTs)
	return i, err
}

const checkUserCooldownStatus = `-- name: CheckUserCooldownStatus :one
SELECT post_forms, verificationdata, email
FROM users
WHERE id = $1
`

type CheckUserCooldownStatusRow struct {
	PostForms        int32       `json:"post_forms"`
	Verificationdata pgtype.Text `json:"verificationdata"`
	Email            pgtype.Text `json:"email"`
}

// Check user form submission cooldown status
func (q *Queries) CheckUserCooldownStatus(ctx context.Context, id int32) (CheckUserCooldownStatusRow, error) {
	row := q.db.QueryRow(ctx, checkUserCooldownStatus, id)
	var i CheckUserCooldownStatusRow
	err := row.Scan(&i.PostForms, &i.Verificationdata, &i.Email)
	return i, err
}

const checkUserOwnsOtherChannels = `-- name: CheckUserOwnsOtherChannels :one
SELECT EXISTS(
  SELECT 1
  FROM users u
  INNER JOIN levels l ON u.id = l.user_id
  INNER JOIN channels c ON c.id = l.channel_id
  WHERE u.id = $1
    AND l.access = 500
    AND c.registered_ts > 0
    AND c.deleted = 0
    AND l.deleted = 0
) as owns_channels
`

// Check if user already owns other channels (managerchange.php:443)
func (q *Queries) CheckUserOwnsOtherChannels(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserOwnsOtherChannels, id)
	var owns_channels bool
	err := row.Scan(&owns_channels)
	return owns_channels, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_name, password, flags, email, last_updated, last_updated_by, language_id, question_id, verificationdata, post_forms, signup_ts, signup_ip, maxlogins)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, user_name, password, email, url, question_id, verificationdata, language_id, public_key, post_forms, flags, last_updated_by, last_updated, deleted, tz_setting, signup_cookie, signup_ts, signup_ip, maxlogins, totp_key, backup_codes, backup_codes_read
`

type CreateUserParams struct {
	Username         string            `json:"user_name"`
	Password         password.Password `json:"password"`
	Flags            flags.User        `json:"flags"`
	Email            pgtype.Text       `json:"email"`
	LastUpdated      int32             `json:"last_updated"`
	LastUpdatedBy    pgtype.Text       `json:"last_updated_by"`
	LanguageID       pgtype.Int4       `json:"language_id"`
	QuestionID       pgtype.Int2       `json:"question_id"`
	Verificationdata pgtype.Text       `json:"verificationdata"`
	PostForms        int32             `json:"post_forms"`
	SignupTs         pgtype.Int4       `json:"signup_ts"`
	SignupIp         pgtype.Text       `json:"signup_ip"`
	Maxlogins        pgtype.Int4       `json:"maxlogins"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Password,
		arg.Flags,
		arg.Email,
		arg.LastUpdated,
		arg.LastUpdatedBy,
		arg.LanguageID,
		arg.QuestionID,
		arg.Verificationdata,
		arg.PostForms,
		arg.SignupTs,
		arg.SignupIp,
		arg.Maxlogins,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Url,
		&i.QuestionID,
		&i.Verificationdata,
		&i.LanguageID,
		&i.PublicKey,
		&i.PostForms,
		&i.Flags,
		&i.LastUpdatedBy,
		&i.LastUpdated,
		&i.Deleted,
		&i.TzSetting,
		&i.SignupCookie,
		&i.SignupTs,
		&i.SignupIp,
		&i.Maxlogins,
		&i.TotpKey,
		&i.BackupCodes,
		&i.BackupCodesRead,
	)
	return i, err
}

const getAdminLevel = `-- name: GetAdminLevel :one
SELECT l.access, l.suspend_expires
FROM channels c
  INNER JOIN levels l
    ON c.id = l.channel_id
WHERE c.name = '*' AND l.user_id=$1
`

type GetAdminLevelRow struct {
	Access         int32       `json:"access"`
	SuspendExpires pgtype.Int4 `json:"suspend_expires"`
}

func (q *Queries) GetAdminLevel(ctx context.Context, userID int32) (GetAdminLevelRow, error) {
	row := q.db.QueryRow(ctx, getAdminLevel, userID)
	var i GetAdminLevelRow
	err := row.Scan(&i.Access, &i.SuspendExpires)
	return i, err
}

const getSupportersByUsernames = `-- name: GetSupportersByUsernames :many
SELECT
  u.id,
  u.user_name,
  u.flags,
  u.email,
  u.signup_ts,
  ul.last_seen,
  -- Age validation
  CASE
    WHEN u.signup_ts IS NULL THEN false
    WHEN (EXTRACT(EPOCH FROM NOW())::int - u.signup_ts) / 86400 >= $2::int THEN true
    ELSE false
  END as is_old_enough,
  COALESCE((EXTRACT(EPOCH FROM NOW())::int - u.signup_ts) / 86400, 0) as days_old,
  -- Fraud flag check
  (u.flags & 8) > 0 as has_fraud_flag
FROM users u
INNER JOIN users_lastseen ul ON u.id = ul.user_id
WHERE lower(u.user_name) = ANY(SELECT lower(unnest($1::text[])))
`

type GetSupportersByUsernamesRow struct {
	ID           int32       `json:"id"`
	Username     string      `json:"user_name"`
	Flags        flags.User  `json:"flags"`
	Email        pgtype.Text `json:"email"`
	SignupTs     pgtype.Int4 `json:"signup_ts"`
	LastSeen     pgtype.Int4 `json:"last_seen"`
	IsOldEnough  bool        `json:"is_old_enough"`
	DaysOld      interface{} `json:"days_old"`
	HasFraudFlag bool        `json:"has_fraud_flag"`
}

// Gets all supporter information in one query for efficient validation
// This replaces multiple individual supporter validation queries
func (q *Queries) GetSupportersByUsernames(ctx context.Context, column1 []string, column2 int32) ([]GetSupportersByUsernamesRow, error) {
	rows, err := q.db.Query(ctx, getSupportersByUsernames, column1, column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSupportersByUsernamesRow{}
	for rows.Next() {
		var i GetSupportersByUsernamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Flags,
			&i.Email,
			&i.SignupTs,
			&i.LastSeen,
			&i.IsOldEnough,
			&i.DaysOld,
			&i.HasFraudFlag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT u.id, u.user_name, u.password, u.email, u.url, u.question_id, u.verificationdata, u.language_id, u.public_key, u.post_forms, u.flags, u.last_updated_by, u.last_updated, u.deleted, u.tz_setting, u.signup_cookie, u.signup_ts, u.signup_ip, u.maxlogins, u.totp_key, u.backup_codes, u.backup_codes_read, ul.last_seen, l.code as language_code, l.name as language_name
FROM users u
       INNER JOIN users_lastseen ul ON u.id = ul.user_id
       INNER JOIN languages l ON u.language_id = l.id
WHERE CASE WHEN LENGTH($1::text) != 0 THEN  lower(u.user_name) = lower($1) ELSE true END
  AND CASE WHEN LENGTH($2::text) != 0 THEN lower(u.email) = lower($2) ELSE true END
  AND CASE WHEN $3::int4 > 0 THEN u.id = $3 ELSE true END
LIMIT 1
`

type GetUserParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	ID       int32  `json:"id"`
}

type GetUserRow struct {
	ID               int32             `json:"id"`
	Username         string            `json:"user_name"`
	Password         password.Password `json:"password"`
	Email            pgtype.Text       `json:"email"`
	Url              pgtype.Text       `json:"url"`
	QuestionID       pgtype.Int2       `json:"question_id"`
	Verificationdata pgtype.Text       `json:"verificationdata"`
	LanguageID       pgtype.Int4       `json:"language_id"`
	PublicKey        pgtype.Text       `json:"public_key"`
	PostForms        int32             `json:"post_forms"`
	Flags            flags.User        `json:"flags"`
	LastUpdatedBy    pgtype.Text       `json:"last_updated_by"`
	LastUpdated      int32             `json:"last_updated"`
	Deleted          pgtype.Int2       `json:"deleted"`
	TzSetting        pgtype.Text       `json:"tz_setting"`
	SignupCookie     pgtype.Text       `json:"signup_cookie"`
	SignupTs         pgtype.Int4       `json:"signup_ts"`
	SignupIp         pgtype.Text       `json:"signup_ip"`
	Maxlogins        pgtype.Int4       `json:"maxlogins"`
	TotpKey          pgtype.Text       `json:"totp_key"`
	BackupCodes      []byte            `json:"backup_codes"`
	BackupCodesRead  pgtype.Bool       `json:"backup_codes_read"`
	LastSeen         pgtype.Int4       `json:"last_seen"`
	LanguageCode     pgtype.Text       `json:"language_code"`
	LanguageName     pgtype.Text       `json:"language_name"`
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, arg.Username, arg.Email, arg.ID)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.Url,
		&i.QuestionID,
		&i.Verificationdata,
		&i.LanguageID,
		&i.PublicKey,
		&i.PostForms,
		&i.Flags,
		&i.LastUpdatedBy,
		&i.LastUpdated,
		&i.Deleted,
		&i.TzSetting,
		&i.SignupCookie,
		&i.SignupTs,
		&i.SignupIp,
		&i.Maxlogins,
		&i.TotpKey,
		&i.BackupCodes,
		&i.BackupCodesRead,
		&i.LastSeen,
		&i.LanguageCode,
		&i.LanguageName,
	)
	return i, err
}

const getUserBackupCodes = `-- name: GetUserBackupCodes :one
SELECT backup_codes, backup_codes_read
FROM users
WHERE id = $1
`

type GetUserBackupCodesRow struct {
	BackupCodes     []byte      `json:"backup_codes"`
	BackupCodesRead pgtype.Bool `json:"backup_codes_read"`
}

// Gets user's backup codes and read status
func (q *Queries) GetUserBackupCodes(ctx context.Context, id int32) (GetUserBackupCodesRow, error) {
	row := q.db.QueryRow(ctx, getUserBackupCodes, id)
	var i GetUserBackupCodesRow
	err := row.Scan(&i.BackupCodes, &i.BackupCodesRead)
	return i, err
}

const getUserChannelLimit = `-- name: GetUserChannelLimit :one

SELECT
  CASE
    WHEN u.flags & 1 > 0 THEN $2::int -- Admin limit
    WHEN u.flags & 2 > 0 THEN $3::int -- Supporter limit
    ELSE $4::int                       -- Regular user limit
  END as channel_limit
FROM users u
WHERE u.id = $1
`

type GetUserChannelLimitParams struct {
	ID      int32 `json:"id"`
	Column2 int32 `json:"column_2"`
	Column3 int32 `json:"column_3"`
	Column4 int32 `json:"column_4"`
}

// Channel Registration related user queries
// Gets the channel limit for a user based on their flags
func (q *Queries) GetUserChannelLimit(ctx context.Context, arg GetUserChannelLimitParams) (int32, error) {
	row := q.db.QueryRow(ctx, getUserChannelLimit,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var channel_limit int32
	err := row.Scan(&channel_limit)
	return channel_limit, err
}

const getUserChannelMemberships = `-- name: GetUserChannelMemberships :many
SELECT l.channel_id, c.name as channel_name, l.access as access_level, l.added as joined_at,
       (SELECT COUNT(*) FROM levels WHERE channel_id = l.channel_id AND deleted = 0) as member_count
FROM levels l
INNER JOIN channels c ON l.channel_id = c.id
WHERE l.user_id = $1 AND l.deleted = 0 AND c.deleted = 0
ORDER BY l.access DESC, c.name ASC
`

type GetUserChannelMembershipsRow struct {
	ChannelID   int32       `json:"channel_id"`
	ChannelName string      `json:"channel_name"`
	AccessLevel int32       `json:"access_level"`
	JoinedAt    pgtype.Int4 `json:"joined_at"`
	MemberCount int64       `json:"member_count"`
}

func (q *Queries) GetUserChannelMemberships(ctx context.Context, userID int32) ([]GetUserChannelMembershipsRow, error) {
	rows, err := q.db.Query(ctx, getUserChannelMemberships, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserChannelMembershipsRow{}
	for rows.Next() {
		var i GetUserChannelMembershipsRow
		if err := rows.Scan(
			&i.ChannelID,
			&i.ChannelName,
			&i.AccessLevel,
			&i.JoinedAt,
			&i.MemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserChannels = `-- name: GetUserChannels :many
SELECT c.name, l.channel_id, l.user_id, l.access, l.flags, l.last_modif, l.suspend_expires, l.suspend_by
FROM levels l
INNER JOIN channels c
ON l.channel_id = c.id
WHERE l.user_id = $1
`

type GetUserChannelsRow struct {
	Name           string      `json:"name"`
	ChannelID      int32       `json:"channel_id"`
	UserID         int32       `json:"user_id"`
	Access         int32       `json:"access"`
	Flags          int16       `json:"flags"`
	LastModif      pgtype.Int4 `json:"last_modif"`
	SuspendExpires pgtype.Int4 `json:"suspend_expires"`
	SuspendBy      pgtype.Text `json:"suspend_by"`
}

func (q *Queries) GetUserChannels(ctx context.Context, userID int32) ([]GetUserChannelsRow, error) {
	rows, err := q.db.Query(ctx, getUserChannels, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserChannelsRow{}
	for rows.Next() {
		var i GetUserChannelsRow
		if err := rows.Scan(
			&i.Name,
			&i.ChannelID,
			&i.UserID,
			&i.Access,
			&i.Flags,
			&i.LastModif,
			&i.SuspendExpires,
			&i.SuspendBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByUsernames = `-- name: GetUsersByUsernames :many
SELECT u.id, u.user_name, u.password, u.email, u.url, u.question_id, u.verificationdata, u.language_id, u.public_key, u.post_forms, u.flags, u.last_updated_by, u.last_updated, u.deleted, u.tz_setting, u.signup_cookie, u.signup_ts, u.signup_ip, u.maxlogins, u.totp_key, u.backup_codes, u.backup_codes_read, ul.last_seen, l.code as language_code, l.name as language_name
FROM users u
INNER JOIN users_lastseen ul
ON u.id = ul.user_id
INNER JOIN languages l
ON u.language_id = l.id
WHERE u.user_name ILIKE ANY($1::VARCHAR[])
`

type GetUsersByUsernamesRow struct {
	ID               int32             `json:"id"`
	Username         string            `json:"user_name"`
	Password         password.Password `json:"password"`
	Email            pgtype.Text       `json:"email"`
	Url              pgtype.Text       `json:"url"`
	QuestionID       pgtype.Int2       `json:"question_id"`
	Verificationdata pgtype.Text       `json:"verificationdata"`
	LanguageID       pgtype.Int4       `json:"language_id"`
	PublicKey        pgtype.Text       `json:"public_key"`
	PostForms        int32             `json:"post_forms"`
	Flags            flags.User        `json:"flags"`
	LastUpdatedBy    pgtype.Text       `json:"last_updated_by"`
	LastUpdated      int32             `json:"last_updated"`
	Deleted          pgtype.Int2       `json:"deleted"`
	TzSetting        pgtype.Text       `json:"tz_setting"`
	SignupCookie     pgtype.Text       `json:"signup_cookie"`
	SignupTs         pgtype.Int4       `json:"signup_ts"`
	SignupIp         pgtype.Text       `json:"signup_ip"`
	Maxlogins        pgtype.Int4       `json:"maxlogins"`
	TotpKey          pgtype.Text       `json:"totp_key"`
	BackupCodes      []byte            `json:"backup_codes"`
	BackupCodesRead  pgtype.Bool       `json:"backup_codes_read"`
	LastSeen         pgtype.Int4       `json:"last_seen"`
	LanguageCode     pgtype.Text       `json:"language_code"`
	LanguageName     pgtype.Text       `json:"language_name"`
}

func (q *Queries) GetUsersByUsernames(ctx context.Context, userids []string) ([]GetUsersByUsernamesRow, error) {
	rows, err := q.db.Query(ctx, getUsersByUsernames, userids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByUsernamesRow{}
	for rows.Next() {
		var i GetUsersByUsernamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Email,
			&i.Url,
			&i.QuestionID,
			&i.Verificationdata,
			&i.LanguageID,
			&i.PublicKey,
			&i.PostForms,
			&i.Flags,
			&i.LastUpdatedBy,
			&i.LastUpdated,
			&i.Deleted,
			&i.TzSetting,
			&i.SignupCookie,
			&i.SignupTs,
			&i.SignupIp,
			&i.Maxlogins,
			&i.TotpKey,
			&i.BackupCodes,
			&i.BackupCodesRead,
			&i.LastSeen,
			&i.LanguageCode,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markBackupCodesAsRead = `-- name: MarkBackupCodesAsRead :exec
UPDATE users
SET backup_codes_read = true, last_updated = $2, last_updated_by = $3
WHERE id = $1
`

type MarkBackupCodesAsReadParams struct {
	ID            int32       `json:"id"`
	LastUpdated   int32       `json:"last_updated"`
	LastUpdatedBy pgtype.Text `json:"last_updated_by"`
}

// Marks backup codes as read after user has seen them
func (q *Queries) MarkBackupCodesAsRead(ctx context.Context, arg MarkBackupCodesAsReadParams) error {
	_, err := q.db.Exec(ctx, markBackupCodesAsRead, arg.ID, arg.LastUpdated, arg.LastUpdatedBy)
	return err
}

const updateUserBackupCodes = `-- name: UpdateUserBackupCodes :exec

UPDATE users
SET backup_codes = $2, backup_codes_read = false, last_updated = $3, last_updated_by = $4
WHERE id = $1
`

type UpdateUserBackupCodesParams struct {
	ID            int32       `json:"id"`
	BackupCodes   []byte      `json:"backup_codes"`
	LastUpdated   int32       `json:"last_updated"`
	LastUpdatedBy pgtype.Text `json:"last_updated_by"`
}

// Backup codes related queries
// Updates user's backup codes and marks them as unread
func (q *Queries) UpdateUserBackupCodes(ctx context.Context, arg UpdateUserBackupCodesParams) error {
	_, err := q.db.Exec(ctx, updateUserBackupCodes,
		arg.ID,
		arg.BackupCodes,
		arg.LastUpdated,
		arg.LastUpdatedBy,
	)
	return err
}

const updateUserCooldown = `-- name: UpdateUserCooldown :exec
UPDATE users
SET post_forms = (EXTRACT(EPOCH FROM NOW())::int + $2)
WHERE id = $1
`

// Set user form submission cooldown (managerchange.php:352)
func (q *Queries) UpdateUserCooldown(ctx context.Context, iD int32, column2 interface{}) error {
	_, err := q.db.Exec(ctx, updateUserCooldown, iD, column2)
	return err
}

const updateUserFlags = `-- name: UpdateUserFlags :exec
UPDATE users
SET flags = $2, last_updated = $3, last_updated_by = $4
WHERE id = $1
`

type UpdateUserFlagsParams struct {
	ID            int32       `json:"id"`
	Flags         flags.User  `json:"flags"`
	LastUpdated   int32       `json:"last_updated"`
	LastUpdatedBy pgtype.Text `json:"last_updated_by"`
}

func (q *Queries) UpdateUserFlags(ctx context.Context, arg UpdateUserFlagsParams) error {
	_, err := q.db.Exec(ctx, updateUserFlags,
		arg.ID,
		arg.Flags,
		arg.LastUpdated,
		arg.LastUpdatedBy,
	)
	return err
}

const updateUserLastSeen = `-- name: UpdateUserLastSeen :exec
UPDATE users_lastseen
SET last_updated = EXTRACT(EPOCH FROM NOW())::int,
    last_seen = EXTRACT(EPOCH FROM NOW())::int
WHERE user_id = $1
`

// Updates user's last seen timestamp (used for instant registration)
func (q *Queries) UpdateUserLastSeen(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, updateUserLastSeen, userID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password = $2, last_updated = $3, last_updated_by = $4
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID            int32             `json:"id"`
	Password      password.Password `json:"password"`
	LastUpdated   int32             `json:"last_updated"`
	LastUpdatedBy pgtype.Text       `json:"last_updated_by"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword,
		arg.ID,
		arg.Password,
		arg.LastUpdated,
		arg.LastUpdatedBy,
	)
	return err
}

const updateUserTotpKey = `-- name: UpdateUserTotpKey :exec
UPDATE users
SET totp_key = $2, last_updated = $3, last_updated_by = $4
WHERE id = $1
`

type UpdateUserTotpKeyParams struct {
	ID            int32       `json:"id"`
	TotpKey       pgtype.Text `json:"totp_key"`
	LastUpdated   int32       `json:"last_updated"`
	LastUpdatedBy pgtype.Text `json:"last_updated_by"`
}

func (q *Queries) UpdateUserTotpKey(ctx context.Context, arg UpdateUserTotpKeyParams) error {
	_, err := q.db.Exec(ctx, updateUserTotpKey,
		arg.ID,
		arg.TotpKey,
		arg.LastUpdated,
		arg.LastUpdatedBy,
	)
	return err
}
