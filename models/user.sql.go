// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: user.sql

package models

import (
	"context"

	"github.com/undernetirc/cservice-api/db/types/flags"
	"github.com/undernetirc/cservice-api/db/types/password"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_name, password, flags, email, last_updated, last_updated_by, language_id, question_id, verificationdata, post_forms, signup_ts, signup_ip, maxlogins)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, user_name, password, email, url, question_id, verificationdata, language_id, public_key, post_forms, flags, last_updated_by, last_updated, deleted, tz_setting, signup_cookie, signup_ts, signup_ip, maxlogins, totp_key
`

type CreateUserParams struct {
	UserName         string            `json:"user_name"`
	Password         password.Password `json:"password"`
	Flags            flags.User        `json:"flags"`
	Email            *string           `json:"email"`
	LastUpdated      int32             `json:"last_updated"`
	LastUpdatedBy    *string           `json:"last_updated_by"`
	LanguageID       *int32            `json:"language_id"`
	QuestionID       *int16            `json:"question_id"`
	Verificationdata *string           `json:"verificationdata"`
	PostForms        int32             `json:"post_forms"`
	SignupTs         *int32            `json:"signup_ts"`
	SignupIp         *string           `json:"signup_ip"`
	Maxlogins        *int32            `json:"maxlogins"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserName,
		arg.Password,
		arg.Flags,
		arg.Email,
		arg.LastUpdated,
		arg.LastUpdatedBy,
		arg.LanguageID,
		arg.QuestionID,
		arg.Verificationdata,
		arg.PostForms,
		arg.SignupTs,
		arg.SignupIp,
		arg.Maxlogins,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.Url,
		&i.QuestionID,
		&i.Verificationdata,
		&i.LanguageID,
		&i.PublicKey,
		&i.PostForms,
		&i.Flags,
		&i.LastUpdatedBy,
		&i.LastUpdated,
		&i.Deleted,
		&i.TzSetting,
		&i.SignupCookie,
		&i.SignupTs,
		&i.SignupIp,
		&i.Maxlogins,
		&i.TotpKey,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, user_name, password, email, url, question_id, verificationdata, language_id, public_key, post_forms, flags, last_updated_by, last_updated, deleted, tz_setting, signup_cookie, signup_ts, signup_ip, maxlogins, totp_key
FROM users
WHERE lower(email) = lower($1) LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.Url,
		&i.QuestionID,
		&i.Verificationdata,
		&i.LanguageID,
		&i.PublicKey,
		&i.PostForms,
		&i.Flags,
		&i.LastUpdatedBy,
		&i.LastUpdated,
		&i.Deleted,
		&i.TzSetting,
		&i.SignupCookie,
		&i.SignupTs,
		&i.SignupIp,
		&i.Maxlogins,
		&i.TotpKey,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT u.id, u.user_name, u.password, u.email, u.url, u.question_id, u.verificationdata, u.language_id, u.public_key, u.post_forms, u.flags, u.last_updated_by, u.last_updated, u.deleted, u.tz_setting, u.signup_cookie, u.signup_ts, u.signup_ip, u.maxlogins, u.totp_key, ul.last_seen, l.code as language_code, l.name as language_name
FROM users u
INNER JOIN users_lastseen ul
ON u.id = ul.user_id
INNER JOIN languages l
ON u.language_id = l.id
WHERE u.id = $1 LIMIT 1
`

type GetUserByIDRow struct {
	ID               int32             `json:"id"`
	UserName         string            `json:"user_name"`
	Password         password.Password `json:"password"`
	Email            *string           `json:"email"`
	Url              *string           `json:"url"`
	QuestionID       *int16            `json:"question_id"`
	Verificationdata *string           `json:"verificationdata"`
	LanguageID       *int32            `json:"language_id"`
	PublicKey        *string           `json:"public_key"`
	PostForms        int32             `json:"post_forms"`
	Flags            flags.User        `json:"flags"`
	LastUpdatedBy    *string           `json:"last_updated_by"`
	LastUpdated      int32             `json:"last_updated"`
	Deleted          *int16            `json:"deleted"`
	TzSetting        *string           `json:"tz_setting"`
	SignupCookie     *string           `json:"signup_cookie"`
	SignupTs         *int32            `json:"signup_ts"`
	SignupIp         *string           `json:"signup_ip"`
	Maxlogins        *int32            `json:"maxlogins"`
	TotpKey          *string           `json:"totp_key"`
	LastSeen         *int32            `json:"last_seen"`
	LanguageCode     *string           `json:"language_code"`
	LanguageName     *string           `json:"language_name"`
}

func (q *Queries) GetUserByID(ctx context.Context, id int32) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.Url,
		&i.QuestionID,
		&i.Verificationdata,
		&i.LanguageID,
		&i.PublicKey,
		&i.PostForms,
		&i.Flags,
		&i.LastUpdatedBy,
		&i.LastUpdated,
		&i.Deleted,
		&i.TzSetting,
		&i.SignupCookie,
		&i.SignupTs,
		&i.SignupIp,
		&i.Maxlogins,
		&i.TotpKey,
		&i.LastSeen,
		&i.LanguageCode,
		&i.LanguageName,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, user_name, password, email, url, question_id, verificationdata, language_id, public_key, post_forms, flags, last_updated_by, last_updated, deleted, tz_setting, signup_cookie, signup_ts, signup_ip, maxlogins, totp_key
FROM users
WHERE lower(user_name) = lower($1) LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserName,
		&i.Password,
		&i.Email,
		&i.Url,
		&i.QuestionID,
		&i.Verificationdata,
		&i.LanguageID,
		&i.PublicKey,
		&i.PostForms,
		&i.Flags,
		&i.LastUpdatedBy,
		&i.LastUpdated,
		&i.Deleted,
		&i.TzSetting,
		&i.SignupCookie,
		&i.SignupTs,
		&i.SignupIp,
		&i.Maxlogins,
		&i.TotpKey,
	)
	return i, err
}

const getUserChannels = `-- name: GetUserChannels :many
SELECT c.name, l.channel_id, l.user_id, l.access, l.flags, l.last_modif, l.suspend_expires, l.suspend_by
FROM levels l
INNER JOIN channels c
ON l.channel_id = c.id
WHERE l.user_id = $1
`

type GetUserChannelsRow struct {
	Name           string  `json:"name"`
	ChannelID      int32   `json:"channel_id"`
	UserID         int32   `json:"user_id"`
	Access         int32   `json:"access"`
	Flags          int16   `json:"flags"`
	LastModif      *int32  `json:"last_modif"`
	SuspendExpires *int32  `json:"suspend_expires"`
	SuspendBy      *string `json:"suspend_by"`
}

func (q *Queries) GetUserChannels(ctx context.Context, userID int32) ([]GetUserChannelsRow, error) {
	rows, err := q.db.Query(ctx, getUserChannels, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserChannelsRow{}
	for rows.Next() {
		var i GetUserChannelsRow
		if err := rows.Scan(
			&i.Name,
			&i.ChannelID,
			&i.UserID,
			&i.Access,
			&i.Flags,
			&i.LastModif,
			&i.SuspendExpires,
			&i.SuspendBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
