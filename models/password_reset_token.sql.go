// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: password_reset_token.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredPasswordResetTokens = `-- name: CleanupExpiredPasswordResetTokens :exec
UPDATE password_reset_tokens
SET deleted = 1, last_updated = $2
WHERE expires_at <= $1 AND deleted = 0
`

func (q *Queries) CleanupExpiredPasswordResetTokens(ctx context.Context, expiresAt int32, lastUpdated int32) error {
	_, err := q.db.Exec(ctx, cleanupExpiredPasswordResetTokens, expiresAt, lastUpdated)
	return err
}

const createPasswordResetToken = `-- name: CreatePasswordResetToken :one
INSERT INTO password_reset_tokens (user_id, token, created_at, expires_at, last_updated)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, token, created_at, expires_at, used_at, last_updated, deleted
`

type CreatePasswordResetTokenParams struct {
	UserID      pgtype.Int4 `json:"user_id"`
	Token       string      `json:"token"`
	CreatedAt   int32       `json:"created_at"`
	ExpiresAt   int32       `json:"expires_at"`
	LastUpdated int32       `json:"last_updated"`
}

func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg CreatePasswordResetTokenParams) (PasswordResetToken, error) {
	row := q.db.QueryRow(ctx, createPasswordResetToken,
		arg.UserID,
		arg.Token,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastUpdated,
	)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.LastUpdated,
		&i.Deleted,
	)
	return i, err
}

const deleteExpiredPasswordResetTokens = `-- name: DeleteExpiredPasswordResetTokens :exec
DELETE FROM password_reset_tokens
WHERE expires_at <= $1 AND deleted = 1
`

func (q *Queries) DeleteExpiredPasswordResetTokens(ctx context.Context, expiresAt int32) error {
	_, err := q.db.Exec(ctx, deleteExpiredPasswordResetTokens, expiresAt)
	return err
}

const getActivePasswordResetTokensByUserID = `-- name: GetActivePasswordResetTokensByUserID :many
SELECT id, user_id, token, created_at, expires_at, used_at, last_updated, deleted
FROM password_reset_tokens
WHERE user_id = $1 AND deleted = 0 AND used_at IS NULL AND expires_at > $2
ORDER BY created_at DESC
`

func (q *Queries) GetActivePasswordResetTokensByUserID(ctx context.Context, userID pgtype.Int4, expiresAt int32) ([]PasswordResetToken, error) {
	rows, err := q.db.Query(ctx, getActivePasswordResetTokensByUserID, userID, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PasswordResetToken{}
	for rows.Next() {
		var i PasswordResetToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.UsedAt,
			&i.LastUpdated,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPasswordResetTokenByToken = `-- name: GetPasswordResetTokenByToken :one
SELECT id, user_id, token, created_at, expires_at, used_at, last_updated, deleted
FROM password_reset_tokens
WHERE token = $1 AND deleted = 0 LIMIT 1
`

func (q *Queries) GetPasswordResetTokenByToken(ctx context.Context, token string) (PasswordResetToken, error) {
	row := q.db.QueryRow(ctx, getPasswordResetTokenByToken, token)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.LastUpdated,
		&i.Deleted,
	)
	return i, err
}

const getPasswordResetTokenStats = `-- name: GetPasswordResetTokenStats :one
SELECT
    COUNT(*) as total_tokens,
    COUNT(CASE WHEN used_at IS NOT NULL THEN 1 END) as used_tokens,
    COUNT(CASE WHEN expires_at <= $1 AND used_at IS NULL THEN 1 END) as expired_tokens,
    COUNT(CASE WHEN expires_at > $1 AND used_at IS NULL AND deleted = 0 THEN 1 END) as active_tokens
FROM password_reset_tokens
`

type GetPasswordResetTokenStatsRow struct {
	TotalTokens   int64 `json:"total_tokens"`
	UsedTokens    int64 `json:"used_tokens"`
	ExpiredTokens int64 `json:"expired_tokens"`
	ActiveTokens  int64 `json:"active_tokens"`
}

func (q *Queries) GetPasswordResetTokenStats(ctx context.Context, expiresAt int32) (GetPasswordResetTokenStatsRow, error) {
	row := q.db.QueryRow(ctx, getPasswordResetTokenStats, expiresAt)
	var i GetPasswordResetTokenStatsRow
	err := row.Scan(
		&i.TotalTokens,
		&i.UsedTokens,
		&i.ExpiredTokens,
		&i.ActiveTokens,
	)
	return i, err
}

const invalidateUserPasswordResetTokens = `-- name: InvalidateUserPasswordResetTokens :exec
UPDATE password_reset_tokens
SET deleted = 1, last_updated = $2
WHERE user_id = $1 AND deleted = 0 AND used_at IS NULL
`

func (q *Queries) InvalidateUserPasswordResetTokens(ctx context.Context, userID pgtype.Int4, lastUpdated int32) error {
	_, err := q.db.Exec(ctx, invalidateUserPasswordResetTokens, userID, lastUpdated)
	return err
}

const markPasswordResetTokenAsUsed = `-- name: MarkPasswordResetTokenAsUsed :exec
UPDATE password_reset_tokens
SET used_at = $2, last_updated = $3
WHERE token = $1
`

type MarkPasswordResetTokenAsUsedParams struct {
	Token       string      `json:"token"`
	UsedAt      pgtype.Int4 `json:"used_at"`
	LastUpdated int32       `json:"last_updated"`
}

func (q *Queries) MarkPasswordResetTokenAsUsed(ctx context.Context, arg MarkPasswordResetTokenAsUsedParams) error {
	_, err := q.db.Exec(ctx, markPasswordResetTokenAsUsed, arg.Token, arg.UsedAt, arg.LastUpdated)
	return err
}

const validatePasswordResetToken = `-- name: ValidatePasswordResetToken :one
SELECT id, user_id, token, created_at, expires_at, used_at, last_updated, deleted
FROM password_reset_tokens
WHERE token = $1 AND deleted = 0 AND used_at IS NULL AND expires_at > $2 LIMIT 1
`

func (q *Queries) ValidatePasswordResetToken(ctx context.Context, token string, expiresAt int32) (PasswordResetToken, error) {
	row := q.db.QueryRow(ctx, validatePasswordResetToken, token, expiresAt)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.LastUpdated,
		&i.Deleted,
	)
	return i, err
}
